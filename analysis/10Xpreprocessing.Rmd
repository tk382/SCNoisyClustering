---
title: "10X Pipeline"
site: workflowr::wflow_site
output:
  workflowr::wflow_html:
    theme: yeti
    highlight: tango
    toc: false
    toc_float: 
      collapsed: true
      smooth_scroll: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      comment=NA,
                      warning = FALSE,
                      message = FALSE)
library(MultiAssayExperiment)
library(ggplot2)
library(irlba)
library(matrixStats)
library(inline)
library(quadprog)
library(dplyr)
library(reshape)
library(caret)
library(fossil)
library(pracma)
library(scatterplot3d)
library(igraph) #for nmi
library(Rtsne)
library(diceR)
library(gplots)
library(Matrix)
library(plotly)
library(SCNoisyClustering)
library(SingleCellExperiment)
library(SC3)
library(gridExtra)
set.seed(1)
```

## Read Data : PBMC 27K

Read data. Keep the gene names separately.

```{r read_data}
orig = readMM('data/unnecessary_in_building/pbmc3k/matrix.mtx')
orig_genenames = read.table('data/unnecessary_in_building/pbmc3k/genes.tsv',
                            stringsAsFactors = FALSE)
```


## Quality Control and Cell Selections

Get summary of the cells. The function "cellFilter" removes abnormal cells based on the read counts. The arguments minGene and maxGene restrict the number of genes detected in each cell. In 10X and Drop-seq data, having lower limit of 500 and upper limit of 2000 are generally appropriate. The cells with greater than 2000 detected genes are likeliy to be doublets, and those with less than 500 have too many dropouts. The default values are -Inf and Inf, so users are recommended to inspect the histogram of gene counts and determine the bounds. The function also requires the gene names to discover the mito-genes. Cells with high mitochondrial read proportion can indicate apoptosis. The default is 0.1. 

```{r cell_filter}
nGene = Matrix::colSums(orig > 0)
hist(nGene)
summaryX = cellFilter(X = orig, 
                      genenames = orig_genenames$V2,
                      minGene = 500, 
                      maxGene = 2000, 
                      maxMitoProp = 0.1)
tmpX = summaryX$X
nUMI = summaryX$nUMI
nGene = summaryX$nGene
percent.mito = summaryX$percent.mito
det.rate = summaryX$det.rate

par(mfrow = c(1,4))
boxplot(nUMI, main='nUMI'); 
boxplot(nGene, main='nGene'); 
boxplot(percent.mito, main='mitogene prop'); 
boxplot(det.rate, main='detection rate')
```


## Gene Filtering using normalized dispersion

Next find variable genes using normalized dispersion. First, remove the genes where counts are 0 in all the cells, so that we use genes with at least one UMI count detected in at least one cell are used. Then genes are placed into a number of bins (user's choice in "bins" parameter in "dispersion" function, default is 20) based on their mean expression, and normalized dispersion is calculated as the absolute difference between dispersion and median dispersion of the expression mean, normalized by the median absolute deviation within each bin. (Grace Zheng et al., 2017)

```{r basic_gene_filtering}
X = tmpX[Matrix::rowSums(tmpX) > 0, ]
genenames = orig_genenames[Matrix::rowSums(tmpX) > 0, ]
disp = dispersion(X, bins = 20)
plot(disp$z ~ disp$genemeans,
     xlab = "mean expression",
     ylab = "normalized dispersion")
select = which(abs(disp$z) > 1)
X = X[select, ]
genenames = genenames[select,]
```


## UMI Normalization

Use quantile-normalization to make the distribution of each cell the same. 

```{r normalize_library}
X = quantile_normalize(as.matrix(X))
```


## Correct Detection Rate

```{r log_transform_and_det_correction}
#take log
logX = as.matrix(log(X + 1))

#check dependency
out = correct_detection_rate(logX, det.rate)

#regress out
log.cpm = logX #not correct the detection rate (no strict linear pattern)
#if there is a pattern, log.cpm = out$residual
```


## Dimension reduction on the data for visualization.

```{r tsne}
pc.base = irlba(log.cpm, 20)
tsne.base = Rtsne(pc.base$v[,1:10], dims=2, perplexity = 100, pca=FALSE)
rm(pc.base)
plot(tsne.base$Y, cex=0.5)
```

Run SLSL on the log.cpm matrix.

```{r slsl, cahce=TRUE}
out.base = SLSL(log.cpm, log=FALSE,
                filter = FALSE,
                correct_detection_rate = FALSE,
                klist = c(200,250,300),
                sigmalist = c(1,1.5,2),
                kernel_type = "pearson",
                verbose=FALSE)
tab = table(out.base$result)
plot(tsne.base$Y, col=rainbow(7)[out.base$result],
     xlab = 'tsne1', ylab='tsne2', main="SLSL result", cex = 0.5)
```


### Compare with SC3

The default settings of SC3 leads to error "Distribution of gene expression in cells is too skewed towards 0", so we use the pre-processed data and does not use the filtering method of SC3. The number of clusters was determined by the default method. 

```{r sc3_2}
library(SingleCellExperiment)
library(SC3)
rownames(X) = genenames[,2]
colnames(X) = paste0("C", 1:ncol(X))
tmpX = as.matrix(X)
sce = SingleCellExperiment(
  assays = list(
    counts = tmpX,
    logcounts = as.matrix(log(X+1))
  ),
  colData = colnames(tmpX)
)
rowData(sce)$feature_symbol = rownames(tmpX)
sce = sc3_prepare(sce, kmeans_nstart = 50)
sce = sc3_estimate_k(sce)
N = ncol(tmpX)
k = metadata(sce)$k_estimation
sce = sc3(sce, ks=9, biology = FALSE, gene_filter=FALSE,
         kmeans_nstart=50)
col_data_selected = colData(sce)
plot(tsne.base$Y, col=rainbow(10)[col_data_selected$sc3_9_clusters], cex=0.5,
     ylab='tsne2', xlab='tsne1', main='SC3 result')
```

## Biomarkers from log.cpm matrix in our pre-processing.

We use Kolgomorov-smirov test to select some of the genes for the clusters not found in SC3 result to verify that our clustering result is based on real signals. 

```{r markers1, warning=FALSE}
gene_selected_names = c('S100A4','B2M','LGALS1','S100A9','S100A8', 'LST1')
gene_selected = match(gene_selected_names, genenames$V2)
ind = gene_selected
df = data.frame(tsne1 = tsne.base$Y[,1], tsne2 = tsne.base$Y[,2],
                S100A4 = log.cpm[ind[1], ],
                B2M = log.cpm[ind[2], ],
                LGALS1 = log.cpm[ind[3],],
                S100A9 = log.cpm[ind[4], ],
                S100A8 = log.cpm[ind[5],],
                LST1 = log.cpm[ind[6], ])
g1 = ggplot(df, aes(x=tsne1, y=tsne2, col = S100A4)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('S100A4')
g2 = ggplot(df, aes(x=tsne1, y=tsne2, col = B2M)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('B2M')
g3 = ggplot(df, aes(x=tsne1, y=tsne2, col = LGALS1)) + geom_point(size=0.1) + 
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('LGALS1')
g4 = ggplot(df, aes(x=tsne1, y=tsne2, col = S100A9)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('S100A9')
g5 = ggplot(df, aes(x=tsne1, y=tsne2, col = S100A8)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('S100A8')
g6 = ggplot(df, aes(x=tsne1, y=tsne2, col = LST1)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('LST1')

grid.arrange(g1,g2,g3, g4,g5,g6,nrow=2)

```


## Compare with results using known markers.

I also check the markers provided in the past works about the same data set. The gene names used below are from either Seurat's tutorial or the original 10X paper about PBMC cells Zheng et al. 

```{r biomarkers}
#list comes from 10X paper and Seurat
ind = which(genenames$V2 %in% c('CD3D', 'CD8A', 'NKG7', 'FCER1A', 'CD16', 'S100A8',
                                     'MS4A1', 'GNLY', 'CD3E', 'CD14', 'FCGR3A',
                                     'LYZ','PPBP'))
genenames$V2[ind]
df = data.frame(tsne1 = tsne.base$Y[,1], tsne2 = tsne.base$Y[,2],
                S100A8 = log.cpm[ind[1], ],
                FCER1A = log.cpm[ind[2], ],
                GNLY = log.cpm[ind[3], ],
                PPBP = log.cpm[ind[4], ],
                LYZ = log.cpm[ind[5], ],
                NKG7 = log.cpm[ind[6], ])

g1 = ggplot(df, aes(x=tsne1, y=tsne2, col = S100A8)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('S100A8')
g2 = ggplot(df, aes(x=tsne1, y=tsne2, col = FCER1A)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('FCER1A')
g3 = ggplot(df, aes(x=tsne1, y=tsne2, col = GNLY)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('GNLY')
g4 = ggplot(df, aes(x=tsne1, y=tsne2, col = PPBP)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('PPBP')
g5 = ggplot(df, aes(x=tsne1, y=tsne2, col = LYZ)) + geom_point(size=0.1) + scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('LYZ')
g6 = ggplot(df, aes(x=tsne1, y=tsne2, col = NKG7)) + geom_point(size=0.1) + scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('NKG7')


grid.arrange(g1,g2,g3,g4,
             g5,g6, nrow=2)
```
