---
title: "10X Example"
site: workflowr::wflow_site
output:
  workflowr::wflow_html:
    theme: yeti
    highlight: tango
    toc: true
    toc_float: 
      collapsed: true
      smooth_scroll: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      comment=NA,
                      warning = FALSE,
                      message = FALSE)
library(MultiAssayExperiment)
library(ggplot2)
library(irlba)
library(matrixStats)
library(inline)
library(quadprog)
library(dplyr)
library(reshape)
library(caret)
library(fossil)
library(pracma)
library(scatterplot3d)
library(igraph) #for nmi
library(Rtsne)
library(diceR)
library(gplots)
library(Matrix)
library(plotly)
library(SCNoisyClustering)
library(SingleCellExperiment)
library(SC3)
library(gridExtra)
R.utils::sourceDirectory("R/", modifiedOnly=FALSE)
Rcpp::sourceCpp('src/SCNoisyClustering.cpp')
```

## Read Data : PBMC 27K

Read data and keep the gene names separately.

```{r read_data}
orig = readMM('data/unnecessary_in_building/pbmc3k/matrix.mtx')
orig_genenames = read.table('data/unnecessary_in_building/pbmc3k/genes.tsv',
                            stringsAsFactors = FALSE)
```


## Quality Control and Cell Selections

Get summary of the cells. The function "cellFilter" removes abnormal cells based on the gene counts. The arguments minGene and maxGene restrict the number of genes detected in each cell. In 10X and Drop-seq data, having lower limit of 500 and upper limit of 2000 are generally appropriate. The cells with greater than 2000 detected genes are likeliy to be doublets, and those with less than 500 have too many dropouts and does not have enough information. The default values are -Inf and Inf, so users are recommended to inspect the histogram of gene counts and determine the bounds. The function also requires the gene names to discover the mito-genes. Cells with high mitochondrial read proportion can indicate apoptosis. The default is 0.1. 

```{r cell_filter}
nGene = Matrix::colSums(orig > 0)
hist(nGene)
summaryX = cellFilter(X = orig, 
                      genenames = orig_genenames$V2,
                      minGene = 500, 
                      maxGene = 2000, 
                      maxMitoProp = 0.1)
tmpX = summaryX$X
nUMI = summaryX$nUMI
nGene = summaryX$nGene
percent.mito = summaryX$percent.mito
det.rate = summaryX$det.rate

par(mfrow = c(1,4))
boxplot(nUMI, main='nUMI'); 
boxplot(nGene, main='nGene'); 
boxplot(percent.mito, main='mitogene prop'); 
boxplot(det.rate, main='detection rate')
```


## Gene Filtering

Next find variable genes using normalized dispersion. First, remove the genes where counts are 0 in all the cells, so that we use genes with at least one UMI count detected in at least one cell are used. Then genes are placed into a number of bins (user's choice in "bins" parameter in "dispersion" function, default is 20) based on their mean expression, and normalized dispersion is calculated as the absolute difference between dispersion and median dispersion of the expression mean, normalized by the median absolute deviation within each bin. (Grace Zheng et al., 2017)

```{r basic_gene_filtering}
X = tmpX[Matrix::rowSums(tmpX) > 0, ]
genenames = orig_genenames[Matrix::rowSums(tmpX) > 0, ]
disp = dispersion(X, bins = 20)
plot(disp$z ~ disp$genemeans,
     xlab = "mean expression",
     ylab = "normalized dispersion")
select = which(abs(disp$z) > 1)
X = X[select, ]
genenames = genenames[select,]
```


## UMI Normalization

Use quantile-normalization to make the distribution of each cell the same. 

```{r normalize_library}
X = quantile_normalize(as.matrix(X))
```


## Correct Detection Rate

```{r log_transform_and_det_correction}
#take log
logX = as.matrix(log(X + 1))

#check dependency
out = correct_detection_rate(logX, det.rate)

#regress out
log.cpm = logX #not correct the detection rate (no strict linear pattern)
#if there is a pattern, log.cpm = out$residual
```


## Dimension reduction and visualization
```{r tsne}
pc.base = irlba(log.cpm, 20)
tsne.base = Rtsne(pc.base$v[,1:10], dims=2, perplexity = 100, pca=FALSE)
rm(pc.base)
plot(tsne.base$Y, cex=0.5)
```

## Run SLSL

```{r slsl, cahce=TRUE}
# out = SLSL(log.cpm, log=FALSE,
#            filter = FALSE,
#            correct_detection_rate = FALSE,
#            klist = c(200,250,300),
#            sigmalist = c(1,1.5,2),
#            kernel_type = "pearson",
#            verbose=FALSE)
# save(out, file = 'slsl_10x.Rdata')
load('analysis/slsl_10x.Rdata')
tab = table(out$result)
plot(tsne.base$Y, col=rainbow(7)[out$result],
     xlab = 'tsne1', ylab='tsne2', main="SLSL result", cex = 0.5)
S = as.matrix(out$S)
ind = sort(out$result, index.return=TRUE)$ix
palette.gr.marray <- colorRampPalette(c("ivory", "pink", "red", "brown"))(50)
heatmap.2(S[ind, ind],
          trace = "none",
          col = palette.gr.marray,
          Colv = F,
          Rowv = F,
          sepcolor = "gray",
          dendrogram = "none",
          labRow = NA,
          labCol = NA,
          key = F,
          breaks = seq(min(S), max(S),length=51),
          cexRow = 1,
          symbreaks = T,
          main = "Similarity Matrix (sorted)")
```


<!-- ## Benchmark SC3 -->

<!-- The default settings of SC3 leads to error "Distribution of gene expression in cells is too skewed towards 0", so we use the pre-processed data and does not use the filtering method of SC3. The number of clusters was determined by the default method.  -->

```{r sc3_2, eval = FALSE, echo = FALSE}
library(SingleCellExperiment)
library(SC3)
rownames(X) = genenames[,2]
colnames(X) = paste0("C", 1:ncol(X))
tmpX = as.matrix(X)
sce = SingleCellExperiment(
  assays = list(
    counts = tmpX,
    logcounts = as.matrix(log(X+1))
  ),
  colData = colnames(tmpX)
)
rowData(sce)$feature_symbol = rownames(tmpX)
sce = sc3_prepare(sce, kmeans_nstart = 50)
sce = sc3_estimate_k(sce)
N = ncol(tmpX)
k = metadata(sce)$k_estimation
sce = sc3(sce, ks=9, biology = FALSE, gene_filter=FALSE,
         kmeans_nstart=50)
col_data_selected = colData(sce)
plot(tsne.base$Y, col=rainbow(10)[col_data_selected$sc3_9_clusters], cex=0.5,
     ylab='tsne2', xlab='tsne1', main='SC3 result')
```




## Known Markers

I also check the markers provided in the past works about the same data set. The gene names used below are from either Seurat's tutorial or the original 10X paper about PBMC cells Zheng et al. 

```{r biomarkers}
sorted_type = sort(out$result, index.return=TRUE)$ix

#list comes from 10X paper and Seurat
ind = which(genenames$V2 %in% c('CD3D', 'CD8A', 'NKG7', 'FCER1A', 'CD16', 'S100A8',
                                     'MS4A1', 'GNLY', 'CD3E', 'CD14', 'FCGR3A',
                                     'LYZ','PPBP'))
genenames$V2[ind]
df = data.frame(tsne1 = tsne.base$Y[,1], tsne2 = tsne.base$Y[,2],
                S100A8 = log.cpm[ind[1], ],
                FCER1A = log.cpm[ind[2], ],
                GNLY = log.cpm[ind[3], ],
                PPBP = log.cpm[ind[4], ],
                LYZ = log.cpm[ind[5], ],
                NKG7 = log.cpm[ind[6], ])

par(mfrow = c(2,3))
for (i in 1:6){
  plot(log.cpm[ind[i], sorted_type], col = as.factor(out$result[sorted_type]),
       main = genenames$V2[ind[i]], cex=0.5)
}


g1 = ggplot(df, aes(x=tsne1, y=tsne2, col = S100A8)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('S100A8')
g2 = ggplot(df, aes(x=tsne1, y=tsne2, col = FCER1A)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('FCER1A')
g3 = ggplot(df, aes(x=tsne1, y=tsne2, col = GNLY)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('GNLY')
g4 = ggplot(df, aes(x=tsne1, y=tsne2, col = PPBP)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('PPBP')
g5 = ggplot(df, aes(x=tsne1, y=tsne2, col = LYZ)) + geom_point(size=0.1) + scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('LYZ')
g6 = ggplot(df, aes(x=tsne1, y=tsne2, col = NKG7)) + geom_point(size=0.1) + scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('NKG7')


grid.arrange(g1,g2,g3,g4,
             g5,g6, nrow=2)
```



## Differentially Expressed Genes

```{r find_markers}
p = rep(0, nrow(log.cpm))
for (i in 1:nrow(log.cpm)){
  p[i] = kruskal.test(log.cpm[i,], as.factor(out$result))$p.value
}
sorted_p = sort(-log10(p), index.return=TRUE, decreasing = TRUE)

sorted_type = sort(out$result, index.return=TRUE)$ix
par(mfrow = c(2,3))
for (i in 1:6){
  plot(log.cpm[sorted_p$ix[i], sorted_type], col = as.factor(out$result[sorted_type]),
       main = genenames[sorted_p$ix[i], 2], cex=0.5)
}


df = data.frame(tsne1 = tsne.base$Y[,1], tsne2 = tsne.base$Y[,2])
df = cbind(df, t(log.cpm[ind[1:6], ]))
colnames(df) = c('tsne1', 'tsne2', genenames[sorted_p$ix[1:6], 2])
colnames(df)[8] = "HLA_DRA"
g1 = ggplot(df, aes(x=tsne1, y=tsne2, col = S100A9)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle(colnames(df)[3])

g2 = ggplot(df, aes(x=tsne1, y=tsne2, col = S100A8)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle(colnames(df)[4])

g3 = ggplot(df, aes(x=tsne1, y=tsne2, col = FCER1G)) + geom_point(size=0.1) + 
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle(colnames(df)[5])

g4 = ggplot(df, aes(x=tsne1, y=tsne2, col = LST1)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle(colnames(df)[6])

g5 = ggplot(df, aes(x=tsne1, y=tsne2, col = AIF1)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle(colnames(df)[7])

g6 = ggplot(df, aes(x=tsne1, y=tsne2, col = HLA_DRA)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle(colnames(df)[8])

grid.arrange(g1,g2,g3, g4,g5,g6,nrow=2)
```
