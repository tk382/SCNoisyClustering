---
title: "10X Example"
site: workflowr::wflow_site
output:
  workflowr::wflow_html:
    theme: yeti
    highlight: tango
    toc: true
    toc_float: 
      collapsed: true
      smooth_scroll: true
    fig_width: 6
    fig_height: 4
---

## Load Package

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      comment=NA,
                      warning = FALSE,
                      message = FALSE)
library(MultiAssayExperiment)
library(ggplot2)
library(plyr)
library(irlba)
library(matrixStats)
library(inline)
library(quadprog)
library(dplyr)
library(reshape)
library(caret)
library(fossil)
library(pracma)
library(scatterplot3d)
library(igraph)
library(Rtsne)
library(diceR)
library(gplots)
library(Matrix)
library(plotly)
library(SCNoisyClustering)
library(SingleCellExperiment)
library(SC3)
library(gridExtra)
```

## Read Data : PBMC 27K

Read data and keep the gene names separately.

```{r read_data}
orig = readMM('data/unnecessary_in_building/pbmc3k/matrix.mtx')
orig_genenames = read.table('data/unnecessary_in_building/pbmc3k/genes.tsv',
                            stringsAsFactors = FALSE)
```


## Quality Control and Cell Selections

First, "cellFilter" function inspects the UMI distribution of each cell and remove abnormal ones. The arguments minGene and maxGene restrict the number of genes detected (at least 1 UMI) in each cell. In 10X and Drop-seq data, having lower limit of 500 and upper limit of 2000 are generally appropriate. The cells with greater than 2,000 detected genes are likely to be doublets, and those with less than 500 have too many dropouts and does not have enough information. The default values are -Inf and Inf, so users are recommended to look at the histogram of gene counts and determine the bounds. The function also requires the gene names to discover the mito-genes. Cells with high mitochondrial read proportion can indicate apoptosis. The default is 0.1. 

```{r cell_filter}
nGene = Matrix::colSums(orig > 0)
hist(nGene)
summaryX = cellFilter(X = orig, 
                      genenames = orig_genenames$V2,
                      minGene = 500, 
                      maxGene = 2000, 
                      maxMitoProp = 0.1)
tmpX = summaryX$X
nUMI = summaryX$nUMI
nGene = summaryX$nGene
percent.mito = summaryX$percent.mito
det.rate = summaryX$det.rate

par(mfrow = c(1,4))
boxplot(nUMI, main='nUMI'); 
boxplot(nGene, main='nGene'); 
boxplot(percent.mito, main='mitogene prop'); 
boxplot(det.rate, main='detection rate')
```


## Gene Filtering

Next find variable genes using normalized dispersion. First, remove the genes where counts are 0 in all the cells, so that we use genes with at least one UMI count detected in at least one cell are used. Then genes are placed into a number of bins (user's choice in "bins" parameter in "dispersion" function, default is 20) based on their mean expression, and normalized dispersion is calculated as the absolute difference between dispersion and median dispersion of the expression mean, normalized by the median absolute deviation within each bin. (Grace Zheng et al., 2017)

```{r basic_gene_filtering}
X = tmpX[Matrix::rowSums(tmpX) > 0, ]
genenames = orig_genenames[Matrix::rowSums(tmpX) > 0, 2]

disp = dispersion(X, bins = 20, robust = F)

outliers = which(disp$normalized_dispersion>5)
plot(disp$normalized_dispersion[-outliers] ~ disp$genemeans[-outliers],
     xlab = "mean expression",
     ylab = "normalized dispersion",
     ylim = c(min(disp$normalized_dispersion),
              max(disp$normalized_dispersion, na.rm=TRUE)))
text(disp$normalized_dispersion[outliers] ~ disp$genemeans[outliers],
     labels = genenames[outliers],
     cex=0.5)

select = which(abs(disp$normalized_dispersion) > 1)
X = X[select, ]
genenames = genenames[select]
```


## UMI Normalization

Use quantile-normalization to make the distribution of each cell the same. 

```{r normalize_library}
X = quantile_normalize(as.matrix(X))
```

<!-- ## Correct Detection Rate -->

```{r log_transform_and_det_correction, echo=FALSE, eval=FALSE}
#take log
logX = as.matrix(log(X + 1))

#check dependency
out = correct_detection_rate(logX, det.rate)

#regress out
log.cpm = logX #not correct the detection rate (no strict linear pattern)
#if there is a pattern, log.cpm = out$residual
```


## Dimension reduction and visualization
```{r tsne}
log.cpm = as.matrix(log(X + 1))
pc.base = irlba(log.cpm, 20)
tsne.base = Rtsne(pc.base$v[,1:10], dims=2, perplexity = 100, pca=FALSE)
rm(pc.base)
plot(tsne.base$Y, cex=0.7, xlab = "tsne1", ylab = "tsne2")
```

## Run SLSL

Run the clustering algorithm SLSL based on the filtered matrix. There are three main parameters. First, "klist" determines the number of neighbors to use to build initial similarity matrix, and around 1/10 of the number of cells is appropriate. "sigmalist" determines the nonlinear structure of Gaussian kernel, and the default of 1, 1.5, and 2.5 work well. The kernel_type determines the distance measure. The four options are "spearman", "pearson", "euclidean", and "combined" which combines information across three different distance measures. 

```{r slsl, cahce=TRUE}
# out = SLSL(log.cpm,
#            klist = c(200,400,600),
#            sigmalist = c(1, 2, 3),
#            kernel_type = "combined",
#            verbose=FALSE)
# tab = table(out$result)
# save(out, file='slsl_10x.Rdata')
load('analysis/slsl_10x.Rdata')
tab = table(out$result)
```

## Analyze result

First visualize the tSNE plot with the clustering result. Also the output includes the similarity matrix that can be visualized using heatmap function, given that there is enough RAM space. 

```{r slsl_analyze}
plot(tsne.base$Y, col=rainbow(11)[out$result],
     xlab = 'tsne1', ylab='tsne2', main="SLSL result", cex = 0.5)
S = as.matrix(out$S)

ind = sort(out$result, index.return=TRUE)$ix
```

```{r visualize_s, echo=F, eval=F}
palette.gr.marray <- colorRampPalette(c("ivory", "red", "brown", "black"))(30)
heatmap.2(S[ind, ind],
          trace = "none",
          col = palette.gr.marray,
          Colv = F,
          Rowv = F,
          sepcolor = "gray",
          dendrogram = "none",
          labRow = NA,
          labCol = NA,
          key = F,
          breaks = seq(0, 0.01,length=31),
          cexRow = 1,
          symbreaks = T,
          main = "Similarity Matrix (sorted)")
```


<!-- ## Benchmark SC3 -->

<!-- The default settings of SC3 leads to error "Distribution of gene expression in cells is too skewed towards 0", so we use the pre-processed data and does not use the filtering method of SC3. The number of clusters was determined by the default method.  -->

```{r sc3_2, eval = FALSE, echo = FALSE}
library(SingleCellExperiment)
library(SC3)
rownames(X) = genenames
colnames(X) = paste0("C", 1:ncol(X))
tmpX = as.matrix(X)
sce = SingleCellExperiment(
  assays = list(
    counts = tmpX,
    logcounts = as.matrix(log(X+1))
  ),
  colData = colnames(tmpX)
)
rowData(sce)$feature_symbol = rownames(tmpX)
sce = sc3_prepare(sce, kmeans_nstart = 50)
sce = sc3_estimate_k(sce)
N = ncol(tmpX)
k = metadata(sce)$sc3$k_estimation
sce = sc3(sce, ks=9, biology = FALSE, gene_filter=FALSE,
         kmeans_nstart=50)
col_data_selected = colData(sce)
plot(tsne.base$Y, col=rainbow(11)[col_data_selected$sc3_9_clusters], cex=0.5,
     ylab='tsne2', xlab='tsne1', main='SC3 result')
```


## Known Markers

If there are known markers, you can check how differentially they are expressed in the clustering result. The markers used below are from the supplementary table of (Schelker et al., 2017)

```{r biomarkers}
sorted_type = sort(out$result, index.return=TRUE)$ix

markers = c('CD3D','CD3E','CD3G','CD27','CD28',
            'CD4',
            'CD8B',
            'CD4','FOXP3','IL2RA','CTLA4',
            'CD19','MS4A1','CD79A','CD79B','BLNK',
            'CD14','CD68','CD163','CSF1R','FCGR3A',
            'IL3RA','CLEC4C','NRP1',
            'FCGR3A','FCGR3B','NCAM1','KLRB1','KLRB1','KLRC1','KLRD1','KLRF1','KLRK1',
            'VWF','CDH5','SELE',
            'FAP','THY1','COL1A1','COL3A1',
            'WFDC2','EPCAM','MCAM',
            'PMEL','MLANA','TYR','MITF'
)
ind = which(orig_genenames$V2 %in% markers)
par(mfrow = c(2,3))
for (i in 1:length(ind)){
  if(sum(tmpX[ind[i], sorted_type]!=0) > 50){
      plot(tmpX[ind[i], sorted_type], col = rainbow(11)[as.factor(out$result[sorted_type])],
       main = orig_genenames[ind[i],2], cex=0.5,
       xlab = 'cells', ylab = 'pre-processed log expression')
  }
}
```

Based on the biomarkers, we can infer that B cells are red, T cells are orange, NK cells are yelow, and monocytes are green. 

## Differentially Expressed Genes

Using Kruskal test, we order the p-values to find the top differentially expressed genes. Below we present 6. 

```{r find_markers}
p = rep(0, nrow(log.cpm))
for (i in 1:nrow(log.cpm)){
  p[i] = kruskal.test(log.cpm[i,], as.factor(out$result))$p.value
}
sorted_p = sort(-log10(p), index.return=TRUE, decreasing = TRUE)
sorted_type = sort(out$result, index.return=TRUE)$ix

par(mfrow = c(2,3))
for (i in 1:6){
  plot(log.cpm[sorted_p$ix[i], sorted_type], 
       col = rainbow(11)[as.factor(out$result[sorted_type])],
       main = genenames[sorted_p$ix[i]], cex=0.5,
       ylab = "pre-processed log expression", xlab = "cells")
}

```


```{r ggplots2, echo=FALSE}
ind = which(genenames %in% c('S100A9', 'S100A8', 'FCER1G', 'LST1', 'AIF1', 'HLA-DRA'))
df = data.frame(tsne1 = tsne.base$Y[,1], tsne2 = tsne.base$Y[,2],
                S100A9 = log.cpm[ind[1], ],
                S100A8 = log.cpm[ind[2], ],
                FCER1G = log.cpm[ind[3], ],
                LST1 = log.cpm[ind[4], ],
                AIF1 = log.cpm[ind[5], ],
                HLA_DRA = log.cpm[ind[6], ])
g1 = ggplot(df, aes(x=tsne1, y=tsne2, col = S100A9)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('S100A9')
g2 = ggplot(df, aes(x=tsne1, y=tsne2, col = S100A8)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('S100A8')
g3 = ggplot(df, aes(x=tsne1, y=tsne2, col = FCER1G)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('FCER1G')
g4 = ggplot(df, aes(x=tsne1, y=tsne2, col = LST1)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('LST1')
g5 = ggplot(df, aes(x=tsne1, y=tsne2, col = AIF1)) + geom_point(size=0.1) + scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('AIF1')
g6 = ggplot(df, aes(x=tsne1, y=tsne2, col = HLA_DRA)) + geom_point(size=0.1) + scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('HLA-DRA')
grid.arrange(g1,g2,g3,g4,
             g5,g6, nrow=2)
```

