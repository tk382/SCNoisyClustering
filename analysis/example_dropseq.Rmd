---
title: "Drop-seq Example"
site: workflowr::wflow_site
output:
  workflowr::wflow_html:
    theme: yeti
    highlight: tango
    toc: true
    toc_float: 
      collapsed: true
      smooth_scroll: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, comment = NA)
library(SCNoisyClustering)
library(matrixStats)
library(inline)
library(parallel)
library(quadprog)
library(irlba)
library(ggplot2)
library(dplyr)
library(reshape)
library(caret)
library(fossil)
library(pracma)
library(scatterplot3d)
library(igraph) #for nmi
library(Rtsne)
library(diceR)
library(gplots)
library(broom)
library(abind)
library(stargazer)
library(gdata)
library(gridExtra)
R.utils::sourceDirectory("../R/", modifiedOnly=FALSE)
Rcpp::sourceCpp('../src/SCNoisyClustering.cpp')
```

## Read Data : Retina Cells 9K

```{r read_data}
library(data.table)
tmp = setDF(fread('../data/unnecessary_in_building/GSM1626794_P14Retina_2.digital_expression.txt'))
orig = tmp[,-1]; rownames(orig) = tmp[,1]; rm(tmp)
genenames = sapply(strsplit(rownames(orig), ":"), function(x) x[3])
gc(verbose=FALSE);
```

## Quality Control and Cell Filter

```{r cell_filter}
nGene = colSums(orig > 0)
hist(nGene)
summaryX = cellFilter(X = orig, 
                      genenames = genenames,
                      minGene = 500, 
                      maxGene = 2000, 
                      maxMitoProp = 0.1)
tmpX = summaryX$X
nUMI = summaryX$nUMI
nGene = summaryX$nGene
percent.mito = summaryX$percent.mito
det.rate = summaryX$det.rate

par(mfrow = c(1,4))
boxplot(nUMI, main='nUMI'); 
boxplot(nGene, main='nGene'); 
boxplot(percent.mito, main='mitochondrial gene', ylim=c(0,0.5)); 
boxplot(det.rate, main='detection rate', ylim=c(0,0.1))
```

## Gene filtering

```{r basic_gene_filtering}
X = tmpX[rowSums(tmpX) > 0, ]
genenames = genenames[rowSums(tmpX) > 0]

#gene filter by dispersion
disp = dispersion(X, bins = 20)
plot(disp$z ~ disp$genemeans,
     xlab = "mean expression",
     ylab = "normalized dispersion")
select = which(abs(disp$z) > 1)
X = X[select, ]
genenames = genenames[select]
```


## UMI Normalization

Use quantile-normalization to make the distribution of each cell the same. 

```{r normalize_library}
nX = quantile_normalize(as.matrix(X))
```

## Correct Detection Rate

After normalization, the linear relationship between the first PC and the detection rate usually disappears. The plots show that even without correction, the two are not heavily correlated. So we do not regress out the detection rate. 

```{r log_transform_and_det_correction}
#take log
logX = as.matrix(log(nX + 1))

#check dependency
out = correct_detection_rate(logX, det.rate)

#regress out
# log.cpm = out$residual
log.cpm = logX
```


## Dimension reduction and visualization.

```{r tsne}
pc = irlba(log.cpm, 20)
plot(pc$d, ylab = "singular values")
tsne = Rtsne(pc$v[,1:5], dims=2, perplexity = 100, pca=FALSE)
plot(tsne$Y, xlab = 'tsne1', ylab = 'tsne2', cex = 0.5)
rm(pc)
```

## Run SLSL

Run SLSL on the log.cpm matrix.

```{r slsl, cache = TRUE}
out = SLSL(log.cpm, log=FALSE,
                filter = FALSE,
                correct_detection_rate = FALSE,
                klist = c(300,400,500),
                sigmalist = c(1,1.5,2),
                kernel_type = "pearson",
                verbose=FALSE)
tab = table(out$result)
ind = sort(out$result, index.return=TRUE)$ix
plot(tsne$Y, col=rainbow(length(tab))[out$result],
     xlab = 'tsne1', ylab='tsne2', main="SLSL", cex = 0.5)
S = as.matrix(out$S)
palette.gr.marray <- colorRampPalette(c("ivory", "pink", "red", "brown"))(50)
pdf("dropseq_heatmap.pdf", width=7, height=7)
heatmap.2(S[ind,ind],
          trace = "none",
          col = palette.gr.marray,
          Colv = F,
          Rowv = F, 
          sepcolor = "gray",
          dendrogram = "none",
          labRow = "none",
          labCol = "none",
          key = F,
          breaks = seq(min(S), max(S),length=51),
          cexRow = 1,
          symbreaks = T)
dev.off()
```

<!-- ## Benchmark SC3 -->

<!-- Using SC3 with our gene and cell filter procedure and disabling the biology and filter feature of the function leads to the following result. Using SC3's default methods lead to the error "distribution of gene expression in cells is too skewed towards 0". -->

```{r sc3, echo=TRUE, eval = FALSE}
library(SingleCellExperiment)
library(SC3)
# colnames(X) = paste0("C", 1:ncol(X))
# sce = SingleCellExperiment(
#   assays = list(
#     counts = X,
#     logcounts = as.matrix(log(X+1))
#   ),
#   colData = colnames(X)
# )
# rowData(sce)$feature_symbol = genenames
# sce = sc3_prepare(sce, kmeans_nstart = 50)
# sce = sc3_estimate_k(sce)
# k = metadata(sce)$sc3$k_estimation
# N = ncol(X)
# sce = sc3(sce, ks=k, biology = FALSE, gene_filter=FALSE,
#          kmeans_nstart=10)
# col_data_selected = colData(sce)
# save(col_data_selected, file  = "analysis/dropseq_sc3_result.Rdata")
load('analysis/dropseq_sc3_result.Rdata')
plot(tsne$Y, col=rainbow(k)[col_data_selected$sc3_6_clusters],
     xlab = 'tsne1', ylab='tsne2', main="SC3", cex = 0.5)
```

## Known Biomarkers

```{r markers}
ind = which(genenames %in% c('Chat', 'Gad1', 'Gad2', 'Slc17a8', 'Slc6a9', 'Gjd2'))
df = data.frame(tsne1 = tsne$Y[,1], tsne2 = tsne$Y[,2],
                Slc17a8 = log.cpm[ind[1], ],
                Gad2 = log.cpm[ind[2], ],
                Gad1 = log.cpm[ind[3],]
                )
g1 = ggplot(df, aes(x=tsne1, y=tsne2, col = Slc17a8)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('Slc17a8')
g2 = ggplot(df, aes(x=tsne1, y=tsne2, col = Gad2)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('Gad2')
g3 = ggplot(df, aes(x=tsne1, y=tsne2, col = Gad1)) + geom_point(size=0.1) +
  scale_colour_gradient(low="pink", high="black") + guides(color = FALSE) + ggtitle('Gad1')
grid.arrange(g1,g2,g3, nrow=1)
```
